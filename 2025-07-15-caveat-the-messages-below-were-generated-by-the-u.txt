
  // ä»»åŠ¡ç±»å‹å®šä¹‰
  interface BaseTask {
    taskId: string;
    name: string;
    enabled: boolean;
    timestamp: number;
    description?: string;
  }

  // æœ¬åœ°ä»»åŠ¡ï¼ˆåŒ…å«å®é™…æ•°æ®ï¼‰
  interface LocalTask extends BaseTask {
    type: 'local';
    textContent: string[];
    settings: TaskSettings;
    actualProcessedItems?: ProcessedItems;
    metadata?: {
      vectorCount: number;
      lastVectorized: number;
      sourceHash?: string;
    };
  }

  // å¤–æŒ‚ä»»åŠ¡ï¼ˆåªåŒ…å«å¼•ç”¨ï¼‰
  interface ExternalTask extends BaseTask {
    type: 'external';
    reference: {
      sourceChatId: string;
      sourceTaskId: string;
      // ç¼“å­˜æºä»»åŠ¡åŸºæœ¬ä¿¡æ¯ï¼Œç”¨äºå¿«é€Ÿæ˜¾ç¤º
      sourceName?: string;
      sourceDescription?: string;
      lastVerified?: number;
    };
    // æœ¬åœ°è¦†ç›–è®¾ç½®
    overrides?: {
      customName?: string;
      customDescription?: string;
    };
  }

  // ç»Ÿä¸€çš„ä»»åŠ¡ç±»å‹
  type VectorTask = LocalTask | ExternalTask;

  3. æœåŠ¡å±‚æ¶æ„

  // ä»»åŠ¡ç®¡ç†æœåŠ¡
  class TaskManagerService {
    // ä»»åŠ¡è§£æå™¨
    private taskResolver: TaskResolver;

    // ä»»åŠ¡éªŒè¯å™¨
    private taskValidator: TaskValidator;

    // è·å–ä»»åŠ¡çš„å®é™…æ•°æ®
    async resolveTask(task: VectorTask): Promise<ResolvedTask> {
      if (task.type === 'local') {
        return { valid: true, data: task };
      }

      // å¤–æŒ‚ä»»åŠ¡è§£æ
      return await this.taskResolver.resolveExternal(task);
    }

    // åˆ›å»ºå¤–æŒ‚ä»»åŠ¡
    async createExternalTask(
      targetChatId: string,
      sourceChatId: string,
      sourceTaskId: string
    ): Promise<ExternalTask> {
      // éªŒè¯æºä»»åŠ¡å­˜åœ¨
      const sourceTask = await this.getTask(sourceChatId, sourceTaskId);
      if (!sourceTask) {
        throw new Error('Source task not found');
      }

      // åˆ›å»ºå¤–æŒ‚ä»»åŠ¡
      const externalTask: ExternalTask = {
        taskId: generateTaskId(),
        type: 'external',
        name: `å¤–æŒ‚ï¼š${sourceTask.name}`,
        enabled: true,
        timestamp: Date.now(),
        reference: {
          sourceChatId,
          sourceTaskId,
          sourceName: sourceTask.name,
          sourceDescription: sourceTask.description,
          lastVerified: Date.now()
        }
      };

      return externalTask;
    }
  }

â— Update Todos
  â¿  â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„æ ¸å¿ƒæ•°æ®ç»“æ„å’Œå­˜å‚¨æœºåˆ¶
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„ä¸šåŠ¡é€»è¾‘å’Œå¤„ç†æµç¨‹
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡ä¸å‘é‡åŒ–ç³»ç»Ÿçš„é›†æˆ
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡åŠŸèƒ½çš„æ¶æ„è®¾è®¡

â— 4. ä¸šåŠ¡é€»è¾‘å¤„ç†

  // ä»»åŠ¡è§£æå™¨
  class TaskResolver {
    async resolveExternal(task: ExternalTask): Promise<ResolvedTask> {
      const { sourceChatId, sourceTaskId } = task.reference;

      // å°è¯•è·å–æºä»»åŠ¡
      const sourceTask = await this.taskStorage.getTask(sourceChatId, sourceTaskId);

      if (!sourceTask) {
        // æºä»»åŠ¡ä¸å­˜åœ¨ï¼Œè¿”å›é™çº§ä¿¡æ¯
        return {
          valid: false,
          reason: 'source_deleted',
          fallback: {
            name: task.reference.sourceName || 'æºæ•°æ®å·²åˆ é™¤',
            description: task.reference.sourceDescription || 'åŸå§‹ä»»åŠ¡å·²è¢«åˆ é™¤'
          }
        };
      }

      // è¿”å›è§£æåçš„ä»»åŠ¡æ•°æ®
      return {
        valid: true,
        data: {
          ...sourceTask,
          // ä¿ç•™å¤–æŒ‚ä»»åŠ¡çš„æœ¬åœ°è®¾ç½®
          taskId: task.taskId,
          name: task.overrides?.customName || task.name,
          enabled: task.enabled, // ä½¿ç”¨å¤–æŒ‚ä»»åŠ¡è‡ªå·±çš„å¯ç”¨çŠ¶æ€
          description: task.overrides?.customDescription || sourceTask.description
        }
      };
    }
  }

  // å‘é‡æŸ¥è¯¢é€‚é…å™¨
  class VectorQueryAdapter {
    async queryWithTask(
      task: VectorTask,
      queryText: string,
      options: QueryOptions
    ): Promise<VectorResult[]> {
      // ç¡®å®šé›†åˆID
      const collectionId = this.getCollectionId(task);

      // æ‰§è¡ŒæŸ¥è¯¢
      const results = await this.storageAdapter.queryCollection(
        collectionId,
        queryText,
        options
      );

      // æ·»åŠ ä»»åŠ¡å…ƒæ•°æ®
      return results.map(result => ({
        ...result,
        metadata: {
          ...result.metadata,
          taskId: task.taskId,
          taskName: task.name,
          isExternal: task.type === 'external'
        }
      }));
    }

    private getCollectionId(task: VectorTask): string {
      if (task.type === 'external') {
        // å¤–æŒ‚ä»»åŠ¡ä½¿ç”¨æºä»»åŠ¡çš„é›†åˆID
        const { sourceChatId, sourceTaskId } = task.reference;
        return `${sourceChatId}_${sourceTaskId}`;
      }
      // æœ¬åœ°ä»»åŠ¡ä½¿ç”¨è‡ªå·±çš„é›†åˆID
      return `${task.chatId}_${task.taskId}`;
    }
  }

â— Update Todos
  â¿  â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„æ ¸å¿ƒæ•°æ®ç»“æ„å’Œå­˜å‚¨æœºåˆ¶
     â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„ä¸šåŠ¡é€»è¾‘å’Œå¤„ç†æµç¨‹
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡ä¸å‘é‡åŒ–ç³»ç»Ÿçš„é›†æˆ
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡åŠŸèƒ½çš„æ¶æ„è®¾è®¡

â— 5. å‘é‡åŒ–ç³»ç»Ÿé›†æˆ

  // ç»Ÿä¸€çš„æŸ¥è¯¢æ¥å£
  class UnifiedVectorQuery {
    async query(
      chatId: string,
      queryText: string,
      options: QueryOptions
    ): Promise<AggregatedResults> {
      const tasks = await this.taskManager.getChatTasks(chatId);
      const enabledTasks = tasks.filter(t => t.enabled);

      const allResults: VectorResult[] = [];

      // å¹¶è¡ŒæŸ¥è¯¢æ‰€æœ‰å¯ç”¨çš„ä»»åŠ¡
      await Promise.all(
        enabledTasks.map(async (task) => {
          try {
            // å¤„ç†å¤–æŒ‚ä»»åŠ¡çš„è§£æ
            if (task.type === 'external') {
              const resolved = await this.taskResolver.resolveExternal(task);
              if (!resolved.valid) {
                console.warn(`Skipping invalid external task: ${task.name}`);
                return;
              }
            }

            // æ‰§è¡ŒæŸ¥è¯¢
            const results = await this.queryAdapter.queryWithTask(
              task,
              queryText,
              options
            );

            allResults.push(...results);
          } catch (error) {
            console.error(`Failed to query task ${task.name}:`, error);
          }
        })
      );

      // èšåˆå’Œæ’åºç»“æœ
      return this.aggregateResults(allResults);
    }
  }

  6. UIç»„ä»¶è®¾è®¡

  // ä»»åŠ¡åˆ—è¡¨ç»„ä»¶
  class TaskListComponent {
    render(tasks: VectorTask[]): HTMLElement {
      return tasks.map(task => {
        const element = this.createTaskElement(task);

        // æ·»åŠ ç±»å‹æ ‡è¯†
        if (task.type === 'external') {
          element.classList.add('external-task');

          // æ£€æŸ¥æºæ•°æ®æœ‰æ•ˆæ€§
          this.checkExternalTaskValidity(task).then(valid => {
            if (!valid) {
              element.classList.add('orphaned');
            }
          });
        }

        return element;
      });
    }

    private createTaskElement(task: VectorTask): HTMLElement {
      const controls = {
        preview: this.createPreviewButton(task),
        rename: this.createRenameButton(task),
        delete: this.createDeleteButton(task),
        toggle: this.createToggleButton(task)
      };

      // å¤–æŒ‚ä»»åŠ¡ç‰¹æ®Šå¤„ç†
      if (task.type === 'external') {
        // éšè—é‡æ–°å‘é‡åŒ–æŒ‰é’®
        controls.revectorize = null;

        // æ·»åŠ "æŸ¥çœ‹æºä»»åŠ¡"æŒ‰é’®
        controls.viewSource = this.createViewSourceButton(task);
      }

      return this.assembleTaskElement(task, controls);
    }
  }

â— Update Todos
  â¿  â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„æ ¸å¿ƒæ•°æ®ç»“æ„å’Œå­˜å‚¨æœºåˆ¶
     â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„ä¸šåŠ¡é€»è¾‘å’Œå¤„ç†æµç¨‹
     â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡ä¸å‘é‡åŒ–ç³»ç»Ÿçš„é›†æˆ
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡åŠŸèƒ½çš„æ¶æ„è®¾è®¡

â— 7. ç”Ÿå‘½å‘¨æœŸç®¡ç†

  // å¤–æŒ‚ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†
  class ExternalTaskLifecycle {
    // åˆ›å»ºå¤–æŒ‚ä»»åŠ¡
    async create(params: CreateExternalTaskParams): Promise<ExternalTask> {
      // 1. éªŒè¯æºä»»åŠ¡å­˜åœ¨
      await this.validateSource(params);

      // 2. æ£€æŸ¥å¾ªç¯å¼•ç”¨
      await this.checkCircularReference(params);

      // 3. åˆ›å»ºå¤–æŒ‚ä»»åŠ¡
      const task = await this.taskManager.createExternalTask(params);

      // 4. æ³¨å†Œä»»åŠ¡å…³ç³»ï¼ˆç”¨äºè¿½è¸ªï¼‰
      await this.registerTaskRelation(task);

      return task;
    }

    // æºèŠå¤©åˆ é™¤æ—¶çš„å¤„ç†
    async handleSourceChatDeleted(chatId: string): Promise<void> {
      const affectedTasks = await this.findExternalTasksBySource(chatId);

      for (const task of affectedTasks) {
        // æ ‡è®°ä¸ºå­¤å„¿ä»»åŠ¡ï¼Œä½†ä¸åˆ é™¤
        await this.markAsOrphaned(task);

        // é€šçŸ¥UIæ›´æ–°
        this.eventBus.emit('task:orphaned', task);
      }
    }

    // å®šæœŸéªŒè¯å¤–æŒ‚ä»»åŠ¡æœ‰æ•ˆæ€§
    async validateExternalTasks(): Promise<void> {
      const allExternalTasks = await this.getAllExternalTasks();

      for (const task of allExternalTasks) {
        const isValid = await this.validateTaskReference(task);

        if (!isValid && !task.orphaned) {
          await this.markAsOrphaned(task);
        } else if (isValid && task.orphaned) {
          await this.restoreFromOrphaned(task);
        }

        // æ›´æ–°æœ€åéªŒè¯æ—¶é—´
        task.reference.lastVerified = Date.now();
      }
    }
  }

  // äº‹ä»¶å¤„ç†
  class TaskEventHandlers {
    constructor(
      private lifecycle: ExternalTaskLifecycle,
      private eventSource: EventSource
    ) {
      this.registerHandlers();
    }

    private registerHandlers() {
      // èŠå¤©åˆ é™¤äº‹ä»¶
      this.eventSource.on('CHAT_DELETED', async (chatId) => {
        // åˆ é™¤æœ¬åœ°ä»»åŠ¡çš„å‘é‡æ•°æ®
        await this.deleteLocalTaskVectors(chatId);

        // å¤„ç†å¤–æŒ‚ä»»åŠ¡
        await this.lifecycle.handleSourceChatDeleted(chatId);

        // æ¸…ç†ä»»åŠ¡å…ƒæ•°æ®
        await this.cleanupTaskMetadata(chatId);
      });

      // å®šæœŸéªŒè¯ï¼ˆæ¯30åˆ†é’Ÿï¼‰
      setInterval(() => {
        this.lifecycle.validateExternalTasks();
      }, 30 * 60 * 1000);
    }
  }

â— Update Todos
  â¿  â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„æ ¸å¿ƒæ•°æ®ç»“æ„å’Œå­˜å‚¨æœºåˆ¶
     â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„ä¸šåŠ¡é€»è¾‘å’Œå¤„ç†æµç¨‹
     â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡ä¸å‘é‡åŒ–ç³»ç»Ÿçš„é›†æˆ
     â˜’ è®¾è®¡å¤–æŒ‚ä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
     â˜ è®¾è®¡å¤–æŒ‚ä»»åŠ¡åŠŸèƒ½çš„æ¶æ„è®¾è®¡

â— 8. å®Œæ•´çš„æ¶æ„è®¾è®¡

  // æ¨¡å—åŒ–æ¶æ„
  export class VectorEnhancedModule {
    private taskManager: TaskManagerService;
    private queryEngine: UnifiedVectorQuery;
    private lifecycle: ExternalTaskLifecycle;
    private ui: TaskUIManager;

    async initialize() {
      // åˆå§‹åŒ–å„ä¸ªæœåŠ¡
      this.taskManager = new TaskManagerService({
        storage: new TaskStorage(),
        resolver: new TaskResolver(),
        validator: new TaskValidator()
      });

      this.queryEngine = new UnifiedVectorQuery({
        taskManager: this.taskManager,
        queryAdapter: new VectorQueryAdapter(),
        aggregator: new ResultAggregator()
      });

      this.lifecycle = new ExternalTaskLifecycle({
        taskManager: this.taskManager,
        eventBus: new EventBus()
      });

      this.ui = new TaskUIManager({
        taskList: new TaskListComponent(),
        externalTaskUI: new ExternalTaskUI(),
        previewModal: new TaskPreviewModal()
      });

      // æ³¨å†Œäº‹ä»¶å¤„ç†
      this.registerEventHandlers();
    }
  }

  9. å®é™…ä½¿ç”¨ç¤ºä¾‹

  // åˆ›å»ºå¤–æŒ‚ä»»åŠ¡
  async function mountExternalTask(sourceChatId, sourceTaskId) {
    const currentChatId = getCurrentChatId();

    try {
      const externalTask = await taskManager.createExternalTask({
        targetChatId: currentChatId,
        sourceChatId: sourceChatId,
        sourceTaskId: sourceTaskId
      });

      toastr.success(`æˆåŠŸæŒ‚è½½ä»»åŠ¡: ${externalTask.name}`);
      await updateTaskList();
    } catch (error) {
      toastr.error(`æŒ‚è½½å¤±è´¥: ${error.message}`);
    }
  }

  // æŸ¥è¯¢æ—¶è‡ªåŠ¨å¤„ç†å¤–æŒ‚ä»»åŠ¡
  async function queryVectors(queryText) {
    const results = await queryEngine.query(
      getCurrentChatId(),
      queryText,
      { limit: 10, threshold: 0.7 }
    );

    // results åŒ…å«äº†æœ¬åœ°ä»»åŠ¡å’Œå¤–æŒ‚ä»»åŠ¡çš„ç»“æœ
    // å¤–æŒ‚ä»»åŠ¡çš„ç»“æœä¼šè‡ªåŠ¨ä»æºä»»åŠ¡çš„å‘é‡æ•°æ®ä¸­è·å–
    return results;
  }

  // UIæ˜¾ç¤º
  function renderTask(task) {
    if (task.type === 'external') {
      return `
        <div class="task-item external-task">
          <span class="task-icon">ğŸ”—</span>
          <span class="task-name">${task.name}</span>
          <span class="task-source">æ¥æº: ${task.reference.sourceChatId}</span>
          ${task.orphaned ? '<span class="orphaned-badge">æºå·²åˆ é™¤</span>' : ''}
        </div>
      `;
    }
    // ... æ¸²æŸ“æœ¬åœ°ä»»åŠ¡
  }
